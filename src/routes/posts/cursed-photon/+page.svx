---
title: The Cursed Parts of Photon
description: I learned how to design while making Photon, and there are questionable decisions still lingering in the source code.
date: 2025-8-29
link: /posts/cursed-photon
keywords: web dev, development, coding, design, lemmy, photon
---

## Context

If you don't know what [Photon](https://use.phtn.app) is, in summary, it is a web client for the fediverse platform [Lemmy](https://join-lemmy.org) made with Svelte and designed to be nice to use and accessible.

I started development of it around **July 2023**, right around the controversy of [the Reddit API changes](https://en.wikipedia.org/wiki/Reddit_API_controversy).

At first it was just to see if I could mess around with the API, but as I grew dissatisfied with the default interface _(called `lemmy-ui`)_, I began to sink some real development time into it.

It's been a long journey and I've learned a lot about web design and overall UI design along with it.

However, some ancient parts of the code are still there to this day that I haven't touched or have avoided fixing for a while--and I've just placed band-aid solutions on top of them.

## A complicated relationship with SSR

Photon is built with [SvelteKit](https://svelte.dev/docs/kit/introduction), a framework for entire frontends, that uses the component library Svelte.

It is intended for multi-page websites like SaaS products that have things like centralized authentication--which Photon does not have at all. What SvelteKit technically supports but isn't primarily intended for is a _cursed hybrid of a multi-page and single-page app_.

Photon, unfortunately, is that. It's meant as a PWA or a website you visit that acts as a web app to call Lemmy instances you log into _client side_, so there is no server. If Photon was a frontend intended for _Lemmy instances themselves_ to host, then credentials would be passed through the server and settings--closer to what SvelteKit intends.

Photon doesn't do any of that (by default). It's all client side (unless hosters enable `PUBLIC_SSR_ENABLED`), but even then, the initial server render uses an unauthenticated, default user. After a second the JavaScript loads and hydrates with your actual settings.

I've been supporting SSR for a while which has led to complicated code and weird design decisions when I'm trying to maintain hybrid support--the source of a lot of soon-to-be-mentioned cursed things.

## Non unified endpoints

Before I talk about the SSR curses, I want to get into a few of the things made cursed by Lemmy itself.

> **Note**
>
> Luckily, the next Lemmy API version (v4) fixes a lot of these issues.
> Still thought I'd mention them.

Certain API endpoints like the inbox or moderation queue aren't _"unified"_--they contain many different types, like private messages, replies, and mentions, but they're each in a separate array. This makes sorting complicated.

Here's an example of what I have to do for the inbox:

```js
const [replies, mentions, privateMessages] = await Promise.all([
	type == 'all' || type == 'replies'
		? client.getReplies({
				...params,
				sort: 'New'
			})
		: { replies: [] },
	type == 'all' || type == 'mentions'
		? client.getPersonMentions({
				...params,
				sort: 'New'
			})
		: {
				mentions: []
			},
	type == 'all' || type == 'messages'
		? client.getPrivateMessages({ ...params })
		: {
				private_messages: []
			}
])

const data = [
	...replies.replies.map(generalizeCommentReply),
	...mentions.mentions.map(generalizePersonMention),
	...privateMessages.private_messages.map(generalizePrivateMessage)
].sort((a, b) => publishedToDate(b.published).getTime() - publishedToDate(a.published).getTime())
```

Not very nice. It'd be a lot better if I _could_ just

```js
const items = await client.getInbox()
```

This type of issue is present in the:

- Moderation queue
- Application queue
- User submission lists
- Search responses
- Saved item lists

and the worst offender of all:

### The modlog

I will just copy the +page.ts load function here:

```js
export const _toModLog = (item: ModAction): ModLog => {
  if ('mod_ban_from_community' in item) {
    const expires = item.mod_ban_from_community.expires
      ? `until ${new Date(item.mod_ban_from_community.expires).toLocaleString()}`
      : 'permanently'
    return {
      moderator: item.moderator,
      moderatee: item.banned_person,
      community: item.community,
      actionName: item.mod_ban_from_community.banned
        ? 'banCommunity'
        : 'unbanCommunity',
      reason: `${item.mod_ban_from_community.reason ?? ''} (banned ${expires})`,
      timestamp: timestamp(item.mod_ban_from_community.when_),
    }
  } else if ('mod_remove_comment' in item) {
    return {
      actionName: item.mod_remove_comment.removed
        ? 'commentRemoval'
        : 'commentRestore',
      community: item.community,
      content: item.comment.content,
      timestamp: timestamp(item.mod_remove_comment.when_),
      moderatee: item.commenter,
      moderator: item.moderator,
      reason: item.mod_remove_comment.reason,
      link: `/comment/${item.comment.id}`,
    }
  } else if ('mod_remove_post' in item) {
    return {
      // ...
    }
  } else if ('mod_add_community' in item) {
    return {
      // ...
    }
  } else if ('mod_feature_post' in item) {
    return {
      // ...
    }
  } else if ('mod_lock_post' in item) {
    return {
      // ...
    }
  } else if ('mod_transfer_community' in item) {
    return {
      // ...
    }
  } else if ('admin_purge_post' in item) {
    return {
      // ...
    }
  } else if ('admin_purge_comment' in item) {
    return {
      // ...
    }
  } else if ('admin_purge_community' in item) {
    return {
      // ...
    }
  } else if ('admin_purge_person' in item) {
    return {
      // ...
    }
  } else if ('mod_ban' in item) {
    return {
      // ...
    }
  } else if ('mod_add' in item) {
    return {
      // ...
    }
  }
}

export async function load() {
  // ...

  const results = await getClient(instance).getModlog({
    community_id: community,
    limit: 20,
    type_: type,
    page: page,
    mod_person_id: modId,
    other_person_id: user,
    post_id: postId,
    comment_id: commentId,
  })
}
```

There are **14** different arrays for each item! There's probably some over-engineered generator function or 200 line type I could make, but honestly, this is one of the least used pages so I don't feel like that's necessary.

## awaitIfServer

A side effect of my hybrid SSR "use-case" is that if I want to defer loading something on the client, I have to load it on the server beforehand or else it will become invisible to users without JS.

This horrible function is how I do that. There's no way to "conditionally" await something in JavaScript, so I landed at this embarassment of a function:

```js
export const awaitIfServer = async <T>(
  promise: Promise<T>,
): Promise<{
  data: Promise<T> | T
}> => ({ data: browser ? promise : await promise })
```

The reason there's a "data" prop is because I couldn't just return an awaited/unawaited promise directly.

I use this in my comment loading, feed loading, and a few other things to make the page view instantly on the client but wait if needed on the server.

## Images

Lemmy has a problem with images. This means Photon does too.

1. Most aren't proxied. There's a setting the admin can enable to enable proxying media through your Lemmy instance, but most don't (Understandably, since it's a high bandwidth cost.)

   - This means whenever you visit Lemmy, you're connecting 20+ random servers to get your image. Who knows what will happen?
   - These servers aren't even just Lemmy instances. They can be random news websites if that's what the thumbnail URL is.

2. Unless images are proxied, there is no way to determine the width beforehand.
3. Scaling is possible, but unsupported. As far as I know, Photon is the only client to use query parameters to request scaled images, so that you aren't downloading a 4K image for a 24x24 profile picture.
   - Because not all images are from Lemmy instances, scaling doesn't work all the time. Some websites will even return an error if you add any of these parameters automatically.
   - Lemmy uses `pict-rs` for image handling, but it doesn't support all the parameters (like a higher quality downscale).
4. More of user error, but alt text isn't pushed hard enough. Mastodon does a good job with this.
5. Your profile picture and banner can be ANY url. It doesn't even have to be an image. I can set my profile picture to a 200K by 200K image that's like 200 megabytes and nuke the data connections of everyone.

## Comments

Comments on Lemmy are actually pretty good. There's just one cursed part:

- You cannot download a single page of comments. If you have a `max_depth` at all, no matter what you set the `limit` to, you **_will_** download every single comment.

## Saved posts

Back to mostly Photon problems!

For the longest time, I was having strange issues with saved posts. I would obtain them by using this function:

```js
const [posts, comments] = await Promise.all([
	client.getPosts({ saved_only: true }),
	client.getComments({ saved_only: true })
])
```

That makes sense, right? Wrong. It took 2 years to figure this out, but sorting will be subtly messed up if you do this, even when sorting by `New`.

The correct API call is:

```js
const [posts, comments] = await client.getPersonDetails({
	user_id: me.user_id,
	saved_only: true
})
```

Oops.

_Will add more as I remember..._
